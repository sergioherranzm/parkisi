/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/reserve/create",{

/***/ "./components/ParkingList.tsx":
/*!************************************!*\
  !*** ./components/ParkingList.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParkingList\": function() { return /* binding */ ParkingList; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _maps_StaticMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maps/StaticMap */ \"./components/maps/StaticMap.tsx\");\n/* harmony import */ var _emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/react/jsx-dev-runtime */ \"./node_modules/@emotion/react/jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js\");\nvar _jsxFileName = \"/mnt/c/Users/Sergio/CursoWebDelvelopment/projects/parkisi/frontend/components/ParkingList.tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\nfunction _EMOTION_STRINGIFIED_CSS_ERROR__() { return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\"; }\n\n\n\n\n\n\n\nvar _ref =  false ? 0 : {\n  name: \"mqrxw-ParkingList\",\n  styles: \"margin-top:0.5rem;margin-bottom:0.5rem;display:flex;label:ParkingList;\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\n\nvar _ref2 =  false ? 0 : {\n  name: \"bok1tq-ParkingList\",\n  styles: \";label:ParkingList;\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\n\nvar _ref3 =  false ? 0 : {\n  name: \"1lm2pur-ParkingList\",\n  styles: \"border-width:1px;--tw-border-opacity:1;border-color:rgba(0, 0, 0, var(--tw-border-opacity));--tw-shadow:0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);padding:0.75rem;border-radius:0.5rem;--tw-bg-opacity:1;background-color:rgba(255, 255, 255, var(--tw-bg-opacity));label:ParkingList;\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\n\nvar _ref4 =  false ? 0 : {\n  name: \"19atwmp-ParkingList\",\n  styles: \"font-size:1.5rem;line-height:2rem;label:ParkingList;\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\n\nvar _ref5 =  false ? 0 : {\n  name: \"wgihwo-ParkingList\",\n  styles: \"border-width:1px;--tw-border-opacity:1;border-color:rgba(0, 0, 0, var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgba(209, 213, 219, var(--tw-bg-opacity));label:ParkingList;\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\n\nvar ParkingList = function ParkingList(props) {\n  _s();\n\n  var lat = props.lat,\n      lng = props.lng;\n  var router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n\n  var _useSWR = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"/parking/address?lat=\".concat(lat, \"&\").concat(lng)),\n      parkings = _useSWR.data;\n\n  return (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n    css: _ref,\n    \"data-tw\": \"my-2 flex\",\n    children: [(parkings === null || parkings === void 0 ? void 0 : parkings.length) > 0 && (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n      children: [(0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n        css: _ref2,\n        \"data-tw\": \"\",\n        children: parkings.map(function (parking) {\n          return (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n            css: _ref3,\n            \"data-tw\": \"border border-black shadow-lg p-3 rounded-lg bg-white\",\n            children: [(0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"h4\", {\n              css: _ref4,\n              \"data-tw\": \"text-2xl\",\n              children: [\"Address: \", parking.address]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 20,\n              columnNumber: 17\n            }, _this), (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"p\", {\n              children: [\"Number of parking slots: \", parking.slots.length]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 21,\n              columnNumber: 17\n            }, _this), (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"button\", {\n              css: _ref5,\n              \"data-tw\": \"border border-black bg-gray-300\",\n              onClick: function onClick() {\n                return router.push(\"/parking/\".concat(parking._id));\n              },\n              children: \"See slots\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 22,\n              columnNumber: 17\n            }, _this)]\n          }, parking._id, true, {\n            fileName: _jsxFileName,\n            lineNumber: 16,\n            columnNumber: 15\n          }, _this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 14,\n        columnNumber: 11\n      }, _this), (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n        children: (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(_maps_StaticMap__WEBPACK_IMPORTED_MODULE_2__.StaticMap, {\n          size: \"600x400\",\n          zoom: 16,\n          markers: markers\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 33,\n          columnNumber: 13\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 32,\n        columnNumber: 11\n      }, _this)]\n    }, void 0, true), !(parkings !== null && parkings !== void 0 && parkings.length) && (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"p\", {\n      children: \"No parking found\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 29\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 11,\n    columnNumber: 5\n  }, _this);\n};\n\n_s(ParkingList, \"3q3gvHfqRTu/hGUhLyxkdWVOslI=\", false, function () {\n  return [next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter, swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"]];\n});\n\n_c = ParkingList;\n\nvar _c;\n\n$RefreshReg$(_c, \"ParkingList\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1BhcmtpbmdMaXN0LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFTyxJQUFNRyxXQUFtRCxHQUFHLFNBQXREQSxXQUFzRCxDQUFDQyxLQUFELEVBQVc7RUFBQTs7RUFDNUUsSUFBUUMsR0FBUixHQUFxQkQsS0FBckIsQ0FBUUMsR0FBUjtFQUFBLElBQWFDLEdBQWIsR0FBcUJGLEtBQXJCLENBQWFFLEdBQWI7RUFDQSxJQUFNQyxNQUFNLEdBQUdQLHNEQUFTLEVBQXhCOztFQUNBLGNBQTJCQywrQ0FBTSxnQ0FBeUJJLEdBQXpCLGNBQWdDQyxHQUFoQyxFQUFqQztFQUFBLElBQWNFLFFBQWQsV0FBUUMsSUFBUjs7RUFFQSxPQUNFO0lBQUE7SUFBQTtJQUFBLFdBQ0csQ0FBQUQsUUFBUSxTQUFSLElBQUFBLFFBQVEsV0FBUixZQUFBQSxRQUFRLENBQUVFLE1BQVYsSUFBbUIsQ0FBbkIsSUFDQztNQUFBLFdBQ0U7UUFBQTtRQUFBO1FBQUEsVUFDR0YsUUFBUSxDQUFDRyxHQUFULENBQWEsVUFBQ0MsT0FBRDtVQUFBLE9BQ1o7WUFBQTtZQUFBO1lBQUEsV0FJRTtjQUFBO2NBQUE7Y0FBQSx3QkFBNEJBLE9BQU8sQ0FBQ0MsT0FBcEM7WUFBQTtjQUFBO2NBQUE7Y0FBQTtZQUFBLFNBSkYsRUFLRTtjQUFBLHdDQUE2QkQsT0FBTyxDQUFDRSxLQUFSLENBQWNKLE1BQTNDO1lBQUE7Y0FBQTtjQUFBO2NBQUE7WUFBQSxTQUxGLEVBTUU7Y0FBQTtjQUFBO2NBRUUsT0FBTyxFQUFFO2dCQUFBLE9BQU1ILE1BQU0sQ0FBQ1EsSUFBUCxvQkFBd0JILE9BQU8sQ0FBQ0ksR0FBaEMsRUFBTjtjQUFBLENBRlg7Y0FBQTtZQUFBO2NBQUE7Y0FBQTtjQUFBO1lBQUEsU0FORjtVQUFBLEdBQ09KLE9BQU8sQ0FBQ0ksR0FEZjtZQUFBO1lBQUE7WUFBQTtVQUFBLFNBRFk7UUFBQSxDQUFiO01BREg7UUFBQTtRQUFBO1FBQUE7TUFBQSxTQURGLEVBbUJFO1FBQUEsVUFDRSx1RUFBQyxzREFBRDtVQUFXLElBQUksRUFBQyxTQUFoQjtVQUEwQixJQUFJLEVBQUUsRUFBaEM7VUFBb0MsT0FBTyxFQUFFQztRQUE3QztVQUFBO1VBQUE7VUFBQTtRQUFBO01BREY7UUFBQTtRQUFBO1FBQUE7TUFBQSxTQW5CRjtJQUFBLGdCQUZKLEVBMkJHLEVBQUNULFFBQUQsYUFBQ0EsUUFBRCxlQUFDQSxRQUFRLENBQUVFLE1BQVgsS0FBcUI7TUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUEsU0EzQnhCO0VBQUE7SUFBQTtJQUFBO0lBQUE7RUFBQSxTQURGO0FBK0JELENBcENNOztHQUFNUDtVQUVJSCxvREFDWUM7OztLQUhoQkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9QYXJraW5nTGlzdC50c3g/ZjUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgdXNlU1dSIGZyb20gJ3N3cic7XG5pbXBvcnQgeyBTdGF0aWNNYXAgfSBmcm9tICcuL21hcHMvU3RhdGljTWFwJztcblxuZXhwb3J0IGNvbnN0IFBhcmtpbmdMaXN0OiBSZWFjdC5GQzx7IGxhdDogc3RyaW5nOyBsbmc6IHN0cmluZyB9PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGxhdCwgbG5nIH0gPSBwcm9wcztcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IHsgZGF0YTogcGFya2luZ3MgfSA9IHVzZVNXUihgL3BhcmtpbmcvYWRkcmVzcz9sYXQ9JHtsYXR9JiR7bG5nfWApO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiB0dz1cIm15LTIgZmxleCBcIj5cbiAgICAgIHtwYXJraW5ncz8ubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPGRpdiB0dz1cIlwiPlxuICAgICAgICAgICAge3BhcmtpbmdzLm1hcCgocGFya2luZykgPT4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5PXtwYXJraW5nLl9pZH1cbiAgICAgICAgICAgICAgICB0dz1cImJvcmRlciBib3JkZXItYmxhY2sgc2hhZG93LWxnIHAtMyByb3VuZGVkLWxnIGJnLXdoaXRlXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxoNCB0dz1cInRleHQtMnhsXCI+QWRkcmVzczoge3BhcmtpbmcuYWRkcmVzc308L2g0PlxuICAgICAgICAgICAgICAgIDxwPk51bWJlciBvZiBwYXJraW5nIHNsb3RzOiB7cGFya2luZy5zbG90cy5sZW5ndGh9PC9wPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIHR3PVwiYm9yZGVyIGJvcmRlci1ibGFjayBiZy1ncmF5LTMwMFwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByb3V0ZXIucHVzaChgL3BhcmtpbmcvJHtwYXJraW5nLl9pZH1gKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBTZWUgc2xvdHNcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8U3RhdGljTWFwIHNpemU9XCI2MDB4NDAwXCIgem9vbT17MTZ9IG1hcmtlcnM9e21hcmtlcnN9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgICAgKX1cblxuICAgICAgeyFwYXJraW5ncz8ubGVuZ3RoICYmIDxwPk5vIHBhcmtpbmcgZm91bmQ8L3A+fVxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXIiLCJ1c2VTV1IiLCJTdGF0aWNNYXAiLCJQYXJraW5nTGlzdCIsInByb3BzIiwibGF0IiwibG5nIiwicm91dGVyIiwicGFya2luZ3MiLCJkYXRhIiwibGVuZ3RoIiwibWFwIiwicGFya2luZyIsImFkZHJlc3MiLCJzbG90cyIsInB1c2giLCJfaWQiLCJtYXJrZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/ParkingList.tsx\n"));

/***/ }),

/***/ "./components/maps/StaticMap.tsx":
/*!***************************************!*\
  !*** ./components/maps/StaticMap.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StaticMap\": function() { return /* binding */ StaticMap; }\n/* harmony export */ });\n/* harmony import */ var react_static_google_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-static-google-map */ \"./node_modules/react-static-google-map/dist/react-static-google-map.umd.js\");\n/* harmony import */ var react_static_google_map__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_static_google_map__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/config */ \"./lib/config.ts\");\n/* harmony import */ var _emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react/jsx-dev-runtime */ \"./node_modules/@emotion/react/jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js\");\nvar _jsxFileName = \"/mnt/c/Users/Sergio/CursoWebDelvelopment/projects/parkisi/frontend/components/maps/StaticMap.tsx\",\n    _this = undefined;\n\n\n\n\nvar StaticMap = function StaticMap(props) {\n  var _props$size = props.size,\n      size = _props$size === void 0 ? '600x600' : _props$size,\n      zoom = props.zoom,\n      markers = props.markers;\n  return (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_static_google_map__WEBPACK_IMPORTED_MODULE_2__.StaticGoogleMap, {\n    size: size,\n    zoom: zoom,\n    apiKey: _lib_config__WEBPACK_IMPORTED_MODULE_0__.GOOGLE_API_KEY,\n    children: markers && markers.map(function (marker) {\n      return (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_static_google_map__WEBPACK_IMPORTED_MODULE_2__.Marker, {\n        location: {\n          lat: marker.coordinates[0],\n          lng: marker.coordinates[1]\n        },\n        color: marker.color,\n        label: marker.label\n      }, marker.label, false, {\n        fileName: _jsxFileName,\n        lineNumber: 30,\n        columnNumber: 11\n      }, _this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 5\n  }, _this);\n};\n/*\n    <StaticGoogleMap size={size} apiKey={GOOGLE_API_KEY}>\n      {markers.map((marker) => {\n        <Marker\n          location={{ lat: marker.coordinates[0], lng: marker.coordinates[1] }}\n          color=\"red\"\n          label={marker.label}\n        />;\n      })}\n\n    </StaticGoogleMap>\n\n\n    <StaticGoogleMap\n      size=\"600x600\"\n      className=\"img-fluid\"\n      apiKey={GOOGLE_API_KEY}\n    >\n      <Marker location=\"6.4488387,3.5496361\" color=\"red\" label=\"1\" />\n    </StaticGoogleMap>\n  \n  <StaticGoogleMap size=\"600x600\" apiKey=\"YOUR_API_KEY\">\n    <Marker.Group label=\"T\" color=\"brown\">\n      <Marker location=\"40.737102,-73.990318\" />\n      <Marker location=\"40.749825,-73.987963\" />\n    </Marker.Group>\n  </StaticGoogleMap>\n  \n  <StaticGoogleMap size=\"600x600\" apiKey=\"YOUR_API_KEY\">\n    <Marker\n      location={{ lat: 40.737102, lng: -73.990318 }}\n      color=\"blue\"\n      label=\"P\"\n    />\n    <Path\n      points={[\n        '40.737102,-73.990318',\n        '40.749825,-73.987963',\n        '40.752946,-73.987384',\n        '40.755823,-73.986397',\n      ]}\n    />\n  </StaticGoogleMap>\n  */\n\n_c = StaticMap;\n\nvar _c;\n\n$RefreshReg$(_c, \"StaticMap\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL21hcHMvU3RhdGljTWFwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRU8sSUFBTUcsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBQ0MsS0FBRCxFQW1CbkI7RUFDSixrQkFBNENBLEtBQTVDLENBQVFDLElBQVI7RUFBQSxJQUFRQSxJQUFSLDRCQUFlLFNBQWY7RUFBQSxJQUEwQkMsSUFBMUIsR0FBNENGLEtBQTVDLENBQTBCRSxJQUExQjtFQUFBLElBQWdDQyxPQUFoQyxHQUE0Q0gsS0FBNUMsQ0FBZ0NHLE9BQWhDO0VBRUEsT0FDRSx1RUFBQyxvRUFBRDtJQUFpQixJQUFJLEVBQUVGLElBQXZCO0lBQTZCLElBQUksRUFBRUMsSUFBbkM7SUFBeUMsTUFBTSxFQUFFSix1REFBakQ7SUFBQSxVQUNHSyxPQUFPLElBQ05BLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQUNDLE1BQUQ7TUFBQSxPQUNWLHVFQUFDLDJEQUFEO1FBRUUsUUFBUSxFQUFFO1VBQ1JDLEdBQUcsRUFBRUQsTUFBTSxDQUFDRSxXQUFQLENBQW1CLENBQW5CLENBREc7VUFFUkMsR0FBRyxFQUFFSCxNQUFNLENBQUNFLFdBQVAsQ0FBbUIsQ0FBbkI7UUFGRyxDQUZaO1FBTUUsS0FBSyxFQUFFRixNQUFNLENBQUNJLEtBTmhCO1FBT0UsS0FBSyxFQUFFSixNQUFNLENBQUNLO01BUGhCLEdBQ09MLE1BQU0sQ0FBQ0ssS0FEZDtRQUFBO1FBQUE7UUFBQTtNQUFBLFNBRFU7SUFBQSxDQUFaO0VBRko7SUFBQTtJQUFBO0lBQUE7RUFBQSxTQURGO0FBZ0JELENBdENNO0FBd0NQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0tBbkZhWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL21hcHMvU3RhdGljTWFwLnRzeD8zMGNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0YXRpY0dvb2dsZU1hcCwgTWFya2VyLCBQYXRoIH0gZnJvbSAncmVhY3Qtc3RhdGljLWdvb2dsZS1tYXAnO1xuaW1wb3J0IHsgR09PR0xFX0FQSV9LRVkgfSBmcm9tICcuLi8uLi9saWIvY29uZmlnJztcblxuZXhwb3J0IGNvbnN0IFN0YXRpY01hcCA9IChwcm9wczoge1xuICBzaXplOiBzdHJpbmc7XG4gIHpvb20/OiBudW1iZXI7XG4gIG1hcmtlcnM/OiB7XG4gICAgY29vcmRpbmF0ZXM6IFtudW1iZXIsIG51bWJlcl07XG4gICAgY29sb3I6XG4gICAgICB8IG51bWJlclxuICAgICAgfCAnYmxhY2snXG4gICAgICB8ICdicm93bidcbiAgICAgIHwgJ2dyZWVuJ1xuICAgICAgfCAncHVycGxlJ1xuICAgICAgfCAneWVsbG93J1xuICAgICAgfCAnYmx1ZSdcbiAgICAgIHwgJ2dyYXknXG4gICAgICB8ICdvcmFuZ2UnXG4gICAgICB8ICdyZWQnXG4gICAgICB8ICd3aGl0ZSc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgfVtdO1xufSkgPT4ge1xuICBjb25zdCB7IHNpemUgPSAnNjAweDYwMCcsIHpvb20sIG1hcmtlcnMgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPFN0YXRpY0dvb2dsZU1hcCBzaXplPXtzaXplfSB6b29tPXt6b29tfSBhcGlLZXk9e0dPT0dMRV9BUElfS0VZfT5cbiAgICAgIHttYXJrZXJzICYmXG4gICAgICAgIG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChcbiAgICAgICAgICA8TWFya2VyXG4gICAgICAgICAgICBrZXk9e21hcmtlci5sYWJlbH1cbiAgICAgICAgICAgIGxvY2F0aW9uPXt7XG4gICAgICAgICAgICAgIGxhdDogbWFya2VyLmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgICBsbmc6IG1hcmtlci5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjb2xvcj17bWFya2VyLmNvbG9yfVxuICAgICAgICAgICAgbGFiZWw9e21hcmtlci5sYWJlbH1cbiAgICAgICAgICAvPlxuICAgICAgICApKX1cbiAgICA8L1N0YXRpY0dvb2dsZU1hcD5cbiAgKTtcbn07XG5cbi8qXG4gICAgPFN0YXRpY0dvb2dsZU1hcCBzaXplPXtzaXplfSBhcGlLZXk9e0dPT0dMRV9BUElfS0VZfT5cbiAgICAgIHttYXJrZXJzLm1hcCgobWFya2VyKSA9PiB7XG4gICAgICAgIDxNYXJrZXJcbiAgICAgICAgICBsb2NhdGlvbj17eyBsYXQ6IG1hcmtlci5jb29yZGluYXRlc1swXSwgbG5nOiBtYXJrZXIuY29vcmRpbmF0ZXNbMV0gfX1cbiAgICAgICAgICBjb2xvcj1cInJlZFwiXG4gICAgICAgICAgbGFiZWw9e21hcmtlci5sYWJlbH1cbiAgICAgICAgLz47XG4gICAgICB9KX1cblxuICAgIDwvU3RhdGljR29vZ2xlTWFwPlxuXG5cbiAgICA8U3RhdGljR29vZ2xlTWFwXG4gICAgICBzaXplPVwiNjAweDYwMFwiXG4gICAgICBjbGFzc05hbWU9XCJpbWctZmx1aWRcIlxuICAgICAgYXBpS2V5PXtHT09HTEVfQVBJX0tFWX1cbiAgICA+XG4gICAgICA8TWFya2VyIGxvY2F0aW9uPVwiNi40NDg4Mzg3LDMuNTQ5NjM2MVwiIGNvbG9yPVwicmVkXCIgbGFiZWw9XCIxXCIgLz5cbiAgICA8L1N0YXRpY0dvb2dsZU1hcD5cbiAgXG4gIDxTdGF0aWNHb29nbGVNYXAgc2l6ZT1cIjYwMHg2MDBcIiBhcGlLZXk9XCJZT1VSX0FQSV9LRVlcIj5cbiAgICA8TWFya2VyLkdyb3VwIGxhYmVsPVwiVFwiIGNvbG9yPVwiYnJvd25cIj5cbiAgICAgIDxNYXJrZXIgbG9jYXRpb249XCI0MC43MzcxMDIsLTczLjk5MDMxOFwiIC8+XG4gICAgICA8TWFya2VyIGxvY2F0aW9uPVwiNDAuNzQ5ODI1LC03My45ODc5NjNcIiAvPlxuICAgIDwvTWFya2VyLkdyb3VwPlxuICA8L1N0YXRpY0dvb2dsZU1hcD5cbiAgXG4gIDxTdGF0aWNHb29nbGVNYXAgc2l6ZT1cIjYwMHg2MDBcIiBhcGlLZXk9XCJZT1VSX0FQSV9LRVlcIj5cbiAgICA8TWFya2VyXG4gICAgICBsb2NhdGlvbj17eyBsYXQ6IDQwLjczNzEwMiwgbG5nOiAtNzMuOTkwMzE4IH19XG4gICAgICBjb2xvcj1cImJsdWVcIlxuICAgICAgbGFiZWw9XCJQXCJcbiAgICAvPlxuICAgIDxQYXRoXG4gICAgICBwb2ludHM9e1tcbiAgICAgICAgJzQwLjczNzEwMiwtNzMuOTkwMzE4JyxcbiAgICAgICAgJzQwLjc0OTgyNSwtNzMuOTg3OTYzJyxcbiAgICAgICAgJzQwLjc1Mjk0NiwtNzMuOTg3Mzg0JyxcbiAgICAgICAgJzQwLjc1NTgyMywtNzMuOTg2Mzk3JyxcbiAgICAgIF19XG4gICAgLz5cbiAgPC9TdGF0aWNHb29nbGVNYXA+XG4gICovXG4iXSwibmFtZXMiOlsiU3RhdGljR29vZ2xlTWFwIiwiTWFya2VyIiwiR09PR0xFX0FQSV9LRVkiLCJTdGF0aWNNYXAiLCJwcm9wcyIsInNpemUiLCJ6b29tIiwibWFya2VycyIsIm1hcCIsIm1hcmtlciIsImxhdCIsImNvb3JkaW5hdGVzIiwibG5nIiwiY29sb3IiLCJsYWJlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/maps/StaticMap.tsx\n"));

/***/ }),

/***/ "./node_modules/react-static-google-map/dist/react-static-google-map.umd.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-static-google-map/dist/react-static-google-map.umd.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"./node_modules/react/index.js\"), __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\")) :\n  0;\n})(this, (function (exports, React, PropTypes) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n  var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n\n      if (enumerableOnly) {\n        symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var statusTypes = {\n    none: 'none',\n    pending: 'pending',\n    rejected: 'rejected',\n    resolved: 'resolved'\n  };\n\n  var Async = function (_React$Component) {\n    _inherits(Async, _React$Component);\n\n    function Async(props) {\n      _classCallCheck(this, Async);\n\n      var _this = _possibleConstructorReturn(this, (Async.__proto__ || Object.getPrototypeOf(Async)).call(this, props));\n\n      _this.state = {\n        status: statusTypes.none\n      };\n      return _this;\n    }\n\n    _createClass(Async, [{\n      key: 'componentWillReceiveProps',\n      value: function componentWillReceiveProps(nP) {\n        if (nP.promise !== this.props.promise) {\n          this.setState({\n            status: statusTypes.none\n          });\n          this.handlePromise(nP.promise);\n        }\n      }\n    }, {\n      key: 'handlePromise',\n      value: function handlePromise(prom) {\n        var _this2 = this;\n\n        this.setState({\n          status: statusTypes.pending\n        });\n        prom.then(function (res) {\n          _this2.setState({\n            status: statusTypes.resolved,\n            value: res\n          });\n        }, function (err) {\n          _this2.setState({\n            status: statusTypes.rejected,\n            value: err\n          });\n        });\n      }\n    }, {\n      key: 'componentWillMount',\n      value: function componentWillMount() {\n        if (this.props.promise) {\n          this.handlePromise(this.props.promise);\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var props = this.props,\n            state = this.state;\n\n        switch (state.status) {\n          case statusTypes.none:\n            if (props.before) {\n              return props.before(this.handlePromise.bind(this));\n            }\n\n            break;\n\n          case statusTypes.pending:\n            if (props.pending) {\n              return props.pending;\n            }\n\n            break;\n\n          case statusTypes.resolved:\n            if (props.then) {\n              return props.then(state.value);\n            }\n\n            break;\n\n          case statusTypes.rejected:\n            if (props.catch) {\n              return props.catch(state.value);\n            }\n\n            break;\n        }\n\n        return null;\n      }\n    }]);\n\n    return Async;\n  }(React__default[\"default\"].Component);\n\n  Async.propTypes = {\n    before: PropTypes__default[\"default\"].func,\n    // renders it's return value before promise is handled\n    then: PropTypes__default[\"default\"].func,\n    // renders it's return value when promise is resolved\n    catch: PropTypes__default[\"default\"].func,\n    // renders it's return value when promise is rejected\n    pending: PropTypes__default[\"default\"].node,\n    // renders it's value when promise is pending\n    promise: PropTypes__default[\"default\"].object // promise itself\n\n  };\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  /**\n   * Use invariant() to assert state which your program assumes to be true.\n   *\n   * Provide sprintf-style format (only %s is supported) and arguments\n   * to provide information about what broke and what you were\n   * expecting.\n   *\n   * The invariant message will be stripped in production, but the invariant\n   * will remain to ensure logic does not differ in production.\n   */\n\n  var NODE_ENV = \"development\";\n\n  var invariant = function (condition, format, a, b, c, d, e, f) {\n    if (NODE_ENV !== 'production') {\n      if (format === undefined) {\n        throw new Error('invariant requires an error message argument');\n      }\n    }\n\n    if (!condition) {\n      var error;\n\n      if (format === undefined) {\n        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n      } else {\n        var args = [a, b, c, d, e, f];\n        var argIndex = 0;\n        error = new Error(format.replace(/%s/g, function () {\n          return args[argIndex++];\n        }));\n        error.name = 'Invariant Violation';\n      }\n\n      error.framesToPop = 1; // we don't care about invariant's own frame\n\n      throw error;\n    }\n  };\n\n  var invariant_1 = invariant;\n\n  function urlBuilder(property, value, separator) {\n    if (value) {\n      return `${property}${separator}${value}`;\n    }\n\n    return null;\n  }\n  function locationBuilder(location) {\n    const urlParts = [];\n\n    if (Array.isArray(location)) {\n      const arrParts = location.map(val => locationBuilder(val));\n      urlParts.push(...arrParts);\n    }\n\n    if (typeof location === 'string' || typeof location === 'number') {\n      urlParts.push(location);\n    }\n\n    if (typeof location === 'object' && location.lat && location.lng) {\n      urlParts.push(`${location.lat},${location.lng}`);\n    }\n\n    return urlParts.join('%7C'); // |\n  }\n  function isStatelessComponent(component) {\n    return !component.render && !(component.prototype && component.prototype.render);\n  }\n  function isClassComponent(component) {\n    return Boolean(component && component.prototype.isReactComponent && component.prototype.render);\n  }\n  function renderStatelessComponent(component, props) {\n    return component(props);\n  }\n  function renderClassComponent(component, props) {\n    return new component(props).render();\n  }\n\n  const markerStrategy = ({\n    props,\n    type: {\n      defaultProps\n    }\n  }, parentProps) => {\n    const {\n      size,\n      color,\n      label,\n      anchor,\n      iconURL,\n      location,\n      scale\n    } = props;\n    invariant_1(location, 'Marker expects a valid location prop');\n    let urlParts = []; // Todo: Remove the property if the defaultProp and Prop value is the same\n\n    urlParts.push(urlBuilder('size', size, ':'));\n    urlParts.push(urlBuilder('color', color, ':'));\n    urlParts.push(urlBuilder('label', label, ':'));\n    urlParts.push(urlBuilder('anchor', anchor, ':'));\n    urlParts.push(urlBuilder('scale', scale, ':'));\n    urlParts.push(urlBuilder('icon', iconURL, ':'));\n    urlParts.push(urlBuilder('', locationBuilder(location), ''));\n    const url = urlParts.filter(x => x).join('%7C'); // |\n\n    return `markers=${url}`;\n  };\n\n  var MarkerStrategy = markerStrategy;\n\n  const pathStrategy = ({\n    props,\n    type: {\n      defaultProps\n    }\n  }, parentProps) => {\n    const {\n      weight,\n      color,\n      fillcolor,\n      geodesic,\n      points\n    } = props;\n    invariant_1(points, 'Path expects a valid points prop');\n    const urlParts = []; // Todo: Remove the property if the defaultProp and Prop value is the same\n\n    urlParts.push(urlBuilder('color', color, ':'));\n    urlParts.push(urlBuilder('weight', weight, ':'));\n    urlParts.push(urlBuilder('fillcolor', fillcolor, ':'));\n    urlParts.push(urlBuilder('geodesic', geodesic, ':'));\n    urlParts.push(urlBuilder('', locationBuilder(points), ''));\n    const url = urlParts.filter(x => x).join('%7C'); //|\n\n    return `path=${url}`;\n  };\n\n  var PathStrategy = pathStrategy;\n\n  const markerGroupStrategy = ({\n    props,\n    type: {\n      defaultProps\n    }\n  }, parentProps) => {\n    const {\n      size,\n      color,\n      label,\n      anchor,\n      iconURL,\n      children,\n      scale\n    } = props;\n    const location = React.Children.map(children, child => child.props.location);\n    return MarkerStrategy({\n      props: {\n        size,\n        color,\n        label,\n        anchor,\n        iconURL,\n        location,\n        scale\n      },\n      type: {\n        defaultProps\n      }\n    });\n  };\n\n  var MarkerGroupStrategy = markerGroupStrategy;\n\n  const pathGroupStrategy = ({\n    props,\n    type: {\n      defaultProps\n    }\n  }, parentProps) => {\n    const {\n      weight,\n      color,\n      fillcolor,\n      geodesic,\n      children\n    } = props;\n    const points = React.Children.map(children, child => child.props.points);\n    return PathStrategy({\n      props: {\n        weight,\n        color,\n        fillcolor,\n        geodesic,\n        points\n      },\n      type: {\n        defaultProps\n      }\n    });\n  };\n\n  var PathGroupStrategy = pathGroupStrategy;\n\n  function nativeStrategy(data) {\n    const {\n      origin,\n      destination,\n      travelMode\n    } = data;\n    let originLocation;\n    let destinationLocation;\n\n    if (typeof origin === 'object' && origin.lat && origin.lng) {\n      originLocation = new google.maps.LatLng(origin);\n    } else {\n      originLocation = origin;\n    }\n\n    if (typeof destination === 'object' && destination.lat && destination.lng) {\n      destinationLocation = new google.maps.LatLng(destination);\n    } else {\n      destinationLocation = destination;\n    }\n\n    const DirectionsService = new google.maps.DirectionsService();\n    return new Promise((resolve, reject) => {\n      DirectionsService.route({\n        origin: originLocation,\n        destination: destinationLocation,\n        travelMode: travelMode.toUpperCase()\n      }, (result, status) => {\n        if (status === google.maps.DirectionsStatus.OK) {\n          resolve(result.routes[0].overview_polyline);\n        }\n\n        reject(status);\n      });\n    });\n  }\n\n  function fetchStrategy(data) {\n    const {\n      baseURL,\n      key,\n      origin,\n      destination\n    } = data;\n    const options = {\n      method: 'GET',\n      mode: 'cors',\n      cache: 'default'\n    };\n    let originLocation;\n    let destinationLocation;\n\n    if (typeof origin === 'object' && origin.lat && origin.lng) {\n      originLocation = `${origin.lat},${origin.lng}`;\n    } else {\n      originLocation = origin;\n    }\n\n    if (typeof destination === 'object' && destination.lat && destination.lng) {\n      destinationLocation = `${destination.lat},${destination.lng}`;\n    } else {\n      destinationLocation = destination;\n    }\n\n    const URL = `${baseURL}?origin=${originLocation}&destination=${destinationLocation}&key=${key}`;\n    return fetch(URL, options).then(res => res.json()).then(res => res.routes[0].overview_polyline.points);\n  }\n\n  const _excluded$1 = [\"baseURL\", \"requestStrategy\", \"origin\", \"destination\", \"apiKey\", \"waypoints\", \"avoid\", \"travelMode\", \"transitMode\", \"transitRoutingPreference\", \"weight\", \"color\", \"fillcolor\", \"geodesic\"];\n  const memoizeDirectionStrategy = (directionStrategy, cache = {}) => {\n    return function ({\n      props\n    }, parentProps) {\n      const key = JSON.stringify(props);\n\n      if (cache[key]) {\n        return cache[key];\n      } else {\n        const promise = directionStrategy.apply(null, arguments).then(strat => {\n          // When this finally resolves, set the value of the cache to\n          // the string path result. Subsequent renders will return a string\n          // and use the base component instead of the Async component and\n          // not cause the flash\n          cache[key] = strat;\n\n          if (parentProps.onCacheUpdate) {\n            parentProps.onCacheUpdate(_objectSpread2({}, cache));\n          }\n\n          return strat;\n        }); // Return the pending promise immedietly and the StaticGoogleMap\n        // usage of the Async component will eventually handle it because\n        // this function returned a Promise. This piece of the code prevents\n        // multiple calls to google on each render, but does not solve the\n        // \"flash\" of the Async component.\n\n        cache[key] = promise;\n        return promise;\n      }\n    };\n  };\n\n  const directionStrategy = ({\n    props,\n    type: {\n      defaultProps\n    }\n  }, parentProps) => {\n    const {\n      baseURL,\n      requestStrategy,\n      origin,\n      destination,\n      apiKey,\n      waypoints,\n      avoid,\n      travelMode,\n      transitMode,\n      transitRoutingPreference,\n      weight,\n      color,\n      fillcolor,\n      geodesic\n    } = props,\n          rest = _objectWithoutProperties(props, _excluded$1);\n\n    invariant_1(origin, 'Origin prop is required');\n    invariant_1(destination, 'Destination prop is required'); // Use the parent's API key if one isn't set here.\n\n    const key = apiKey ? apiKey : parentProps ? parentProps.apiKey : '';\n\n    const data = _objectSpread2({\n      key,\n      baseURL,\n      origin,\n      destination,\n      waypoints,\n      avoid,\n      travelMode,\n      transitMode,\n      transitRoutingPreference\n    }, rest);\n\n    let pathPromise;\n\n    if (typeof requestStrategy !== 'string') {\n      pathPromise = requestStrategy(data);\n    } else {\n      switch (requestStrategy) {\n        case 'native':\n          pathPromise = nativeStrategy(data);\n          break;\n\n        case 'fetch':\n          pathPromise = fetchStrategy(data);\n          break;\n\n        default:\n          throw new Error('Specify a Request strategy to get directions from');\n      }\n    }\n\n    return pathPromise.then(path => PathStrategy({\n      props: {\n        weight,\n        color,\n        fillcolor,\n        geodesic,\n        points: `enc:${path}`\n      },\n      type: {\n        defaultProps\n      }\n    }));\n  };\n\n  var DirectionStrategy = directionStrategy;\n\n  const MapStrategy = props => {\n    const {\n      rootURL,\n      size,\n      zoom,\n      scale,\n      style,\n      mapId,\n      center,\n      format,\n      client,\n      region,\n      visible,\n      channel,\n      maptype,\n      language,\n      signature,\n      apiKey\n    } = props;\n    const urlParts = [];\n    urlParts.push(urlBuilder('size', size, '='));\n    urlParts.push(urlBuilder('zoom', zoom, '='));\n    urlParts.push(urlBuilder('scale', scale, '='));\n    urlParts.push(urlBuilder('style', style, '='));\n    urlParts.push(urlBuilder('map_id', mapId, '='));\n    urlParts.push(urlBuilder('center', center, '=')); // Todo: Allow Objects.\n\n    urlParts.push(urlBuilder('format', format, '='));\n    urlParts.push(urlBuilder('client', client, '='));\n    urlParts.push(urlBuilder('region', region, '='));\n    urlParts.push(urlBuilder('visible', visible, '='));\n    urlParts.push(urlBuilder('channel', channel, '='));\n    urlParts.push(urlBuilder('maptype', maptype, '='));\n    urlParts.push(urlBuilder('language', language, '='));\n    urlParts.push(urlBuilder('signature', signature, '='));\n    urlParts.push(urlBuilder('key', apiKey, '='));\n    const parts = urlParts.filter(x => x).join('&');\n    return `${rootURL}?${parts}`;\n  };\n\n  var MapStrategy$1 = MapStrategy;\n\n  const propTypes$2 = {\n    size: PropTypes__default[\"default\"].oneOf(['tiny', 'mid', 'small', 'normal']),\n    color: PropTypes__default[\"default\"].string,\n    iconURL: PropTypes__default[\"default\"].string,\n    label: PropTypes__default[\"default\"].string,\n    anchor: PropTypes__default[\"default\"].string,\n    location: PropTypes__default[\"default\"].any.isRequired\n  };\n  const defaultProps$2 = {\n    size: 'normal'\n  };\n  const groupPropTypes$1 = {\n    size: PropTypes__default[\"default\"].oneOf(['tiny', 'mid', 'small', 'normal']),\n    color: PropTypes__default[\"default\"].string,\n    iconURL: PropTypes__default[\"default\"].string,\n    label: PropTypes__default[\"default\"].string,\n    anchor: PropTypes__default[\"default\"].string\n  };\n\n  const Marker = () => null;\n\n  Marker.propTypes = propTypes$2;\n  Marker.defaultProps = defaultProps$2;\n\n  const MarkerGroup = () => null;\n\n  MarkerGroup.propTypes = groupPropTypes$1;\n  MarkerGroup.defaultProps = defaultProps$2;\n  Marker.Group = MarkerGroup;\n  var Marker$1 = Marker;\n\n  const propTypes$1 = {\n    weight: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n    color: PropTypes__default[\"default\"].string,\n    fillcolor: PropTypes__default[\"default\"].string,\n    geodesic: PropTypes__default[\"default\"].bool,\n    points: PropTypes__default[\"default\"].any.isRequired\n  };\n  const groupPropTypes = {\n    weight: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n    color: PropTypes__default[\"default\"].string,\n    fillcolor: PropTypes__default[\"default\"].string,\n    geodesic: PropTypes__default[\"default\"].bool\n  };\n  const defaultProps$1 = {\n    weight: 5,\n    geodesic: false\n  };\n\n  const Path = () => null;\n\n  Path.propTypes = propTypes$1;\n  Path.defaultProps = defaultProps$1;\n\n  const PathGroup = () => null;\n\n  PathGroup.propsTypes = groupPropTypes;\n  PathGroup.defaultProps = defaultProps$1;\n  Path.Group = PathGroup;\n  var Path$1 = Path;\n\n  const propTypes = {\n    baseURL: PropTypes__default[\"default\"].string,\n    origin: PropTypes__default[\"default\"].string.isRequired,\n    destination: PropTypes__default[\"default\"].string.isRequired,\n    apiKey: PropTypes__default[\"default\"].string,\n    waypoints: PropTypes__default[\"default\"].any,\n    avoid: PropTypes__default[\"default\"].string,\n    travelMode: PropTypes__default[\"default\"].oneOf(['driving', 'walking', 'bicycling', 'transit']),\n    transitMode: PropTypes__default[\"default\"].oneOf(['bus', 'subway', 'train', 'tram', 'rail']),\n    transitRoutingPreference: PropTypes__default[\"default\"].oneOf(['less_walking', 'fewer_transfers']),\n    requestStrategy: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].oneOf(['fetch', 'native'])]).isRequired,\n    weight: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n    color: PropTypes__default[\"default\"].string,\n    fillcolor: PropTypes__default[\"default\"].string,\n    geodesic: PropTypes__default[\"default\"].bool\n  };\n  const defaultProps = {\n    baseURL: 'https://maps.googleapis.com/maps/api/directions/json',\n    travelMode: 'driving',\n    requestStrategy: 'native',\n    weight: 5,\n    geodesic: false\n  };\n\n  const Direction = () => null;\n\n  Direction.propTypes = propTypes;\n  Direction.defaultProps = defaultProps;\n  var Direction$1 = Direction;\n\n  const _excluded = [\"children\", \"onGenerate\", \"as\"],\n        _excluded2 = [\"rootURL\", \"size\", \"zoom\", \"scale\", \"style\", \"mapId\", \"center\", \"format\", \"client\", \"region\", \"visible\", \"channel\", \"maptype\", \"language\", \"signature\", \"apiKey\", \"cache\", \"onCacheUpdate\"];\n\n  class StaticGoogleMap extends React.Component {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"MemoizedDirectionStrategy\", memoizeDirectionStrategy(DirectionStrategy, _objectSpread2({}, this.props.cache)));\n    }\n\n    buildParts(children, props) {\n      return React__default[\"default\"].Children.map(children, child => {\n        if (! /*#__PURE__*/React__default[\"default\"].isValidElement(child)) {\n          return null;\n        }\n\n        switch (child.type) {\n          case Marker$1:\n            return MarkerStrategy(child, props);\n\n          case Marker$1.Group:\n            return MarkerGroupStrategy(child, props);\n\n          case Path$1:\n            return PathStrategy(child, props);\n\n          case Path$1.Group:\n            return PathGroupStrategy(child, props);\n\n          case Direction$1:\n            if (props.cache) {\n              return this.MemoizedDirectionStrategy(child, props);\n            }\n\n            return DirectionStrategy(child, props);\n\n          default:\n            const componentType = child.type;\n\n            if (isStatelessComponent(componentType)) {\n              return this.buildParts(renderStatelessComponent(componentType, _objectSpread2({}, child.props)), props);\n            }\n\n            if (isClassComponent(componentType)) {\n              return this.buildParts(renderClassComponent(componentType, _objectSpread2({}, child.props)), props);\n            }\n\n            return null;\n        }\n      });\n    }\n\n    render() {\n      const _this$props = this.props,\n            {\n        children,\n        onGenerate,\n        as: Component\n      } = _this$props,\n            props = _objectWithoutProperties(_this$props, _excluded);\n\n      const {\n        rootURL,\n        size,\n        zoom,\n        scale,\n        style,\n        mapId,\n        center,\n        format,\n        client,\n        region,\n        visible,\n        channel,\n        maptype,\n        language,\n        signature,\n        apiKey,\n        cache,\n        onCacheUpdate\n      } = props,\n            componentProps = _objectWithoutProperties(props, _excluded2);\n\n      invariant_1(size, 'size property is not set');\n      invariant_1(children, 'Component must have `Marker`, `Path` or `Direction` child');\n      const childrenUrlParts = this.buildParts(children, props) || [];\n      const mainUrlParts = MapStrategy$1(props);\n      /**\n       * All the parts should return a string if a component that does not return a promise isn't used\n       * The Directions's component returns a promise and would instead use the Async component to render\n       * This allows us render sync otherwise and partially support server side rendering.\n       */\n\n      if (!childrenUrlParts.some(part => typeof part === 'object')) {\n        const childURL = childrenUrlParts.filter(part => part).join('&');\n        const url = `${mainUrlParts}&${childURL}`;\n\n        if (onGenerate) {\n          onGenerate(url);\n        }\n\n        return /*#__PURE__*/React__default[\"default\"].createElement(Component, _extends({}, componentProps, {\n          src: url\n        }));\n      }\n\n      const urlParts = Promise.all(childrenUrlParts).then(parts => `${mainUrlParts}&${parts.filter(part => part).join('&')}`);\n      return /*#__PURE__*/React__default[\"default\"].createElement(Async, {\n        promise: urlParts,\n        then: URL => {\n          if (onGenerate) {\n            onGenerate(URL);\n          }\n\n          return /*#__PURE__*/React__default[\"default\"].createElement(Component, _extends({}, componentProps, {\n            src: URL\n          }));\n        },\n        catch: err => (console.error(err), /*#__PURE__*/React__default[\"default\"].createElement(\"span\", null, \"Image generation failed.\"))\n      });\n    }\n\n  }\n\n  _defineProperty(StaticGoogleMap, \"defaultProps\", {\n    as: 'img',\n    scale: 1,\n    format: 'png',\n    rootURL: 'https://maps.googleapis.com/maps/api/staticmap',\n    apiKey: '',\n    maptype: 'roadmap',\n    cache: true\n  });\n\n  var StaticGoogleMap$1 = StaticGoogleMap;\n\n  exports.Direction = Direction$1;\n  exports.Marker = Marker$1;\n  exports.Path = Path$1;\n  exports.StaticGoogleMap = StaticGoogleMap$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3RhdGljLWdvb2dsZS1tYXAvZGlzdC9yZWFjdC1zdGF0aWMtZ29vZ2xlLW1hcC51bWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLDRDQUFPLEdBQUcsbUJBQU8sQ0FBQyxzREFBWTtBQUN4SCxFQUFFLENBQ3FKO0FBQ3ZKLENBQUMsZ0RBQWdEOztBQUVqRCx1Q0FBdUMsNERBQTREOztBQUVuRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixhQUFhLEdBQUcsYUFBYTtBQUNwRDs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQsc0JBQXNCLElBQUk7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJELG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFdBQVcsR0FBRyxXQUFXO0FBQ25ELE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdCQUFnQixHQUFHLGdCQUFnQjtBQUNsRSxNQUFNO0FBQ047QUFDQTs7QUFFQSxtQkFBbUIsUUFBUSxVQUFVLGVBQWUsZUFBZSxvQkFBb0IsT0FBTyxJQUFJO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSw4REFBOEQ7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRLEdBQUcsTUFBTTtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0hBQXNIO0FBQ3RIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQSwwRkFBMEY7QUFDMUY7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxHQUFHLFNBQVM7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEY7QUFDMUY7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsc0VBQXNFLGFBQWEsR0FBRyxxQ0FBcUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUE0RjtBQUM1RjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0YXRpYy1nb29nbGUtbWFwL2Rpc3QvcmVhY3Qtc3RhdGljLWdvb2dsZS1tYXAudW1kLmpzPzZjYzIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdwcm9wLXR5cGVzJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCcsICdwcm9wLXR5cGVzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuUmVhY3RTdGF0aWNHb29nbGVNYXAgPSB7fSwgZ2xvYmFsLlJlYWN0LCBnbG9iYWwuUHJvcFR5cGVzKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0LCBQcm9wVHlwZXMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG4gIHZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuICB2YXIgUHJvcFR5cGVzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShQcm9wVHlwZXMpO1xuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgIHZhciBrZXksIGk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIHZhciBzdGF0dXNUeXBlcyA9IHtcbiAgICBub25lOiAnbm9uZScsXG4gICAgcGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIHJlamVjdGVkOiAncmVqZWN0ZWQnLFxuICAgIHJlc29sdmVkOiAncmVzb2x2ZWQnXG4gIH07XG5cbiAgdmFyIEFzeW5jID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQXN5bmMsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQXN5bmMocHJvcHMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3luYyk7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBc3luYy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFzeW5jKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc3RhdHVzOiBzdGF0dXNUeXBlcy5ub25lXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBc3luYywgW3tcbiAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoblApIHtcbiAgICAgICAgaWYgKG5QLnByb21pc2UgIT09IHRoaXMucHJvcHMucHJvbWlzZSkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNUeXBlcy5ub25lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVQcm9taXNlKG5QLnByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaGFuZGxlUHJvbWlzZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUHJvbWlzZShwcm9tKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzVHlwZXMucGVuZGluZ1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNUeXBlcy5yZXNvbHZlZCxcbiAgICAgICAgICAgIHZhbHVlOiByZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1R5cGVzLnJlamVjdGVkLFxuICAgICAgICAgICAgdmFsdWU6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucHJvbWlzZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlUHJvbWlzZSh0aGlzLnByb3BzLnByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgc3dpdGNoIChzdGF0ZS5zdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIHN0YXR1c1R5cGVzLm5vbmU6XG4gICAgICAgICAgICBpZiAocHJvcHMuYmVmb3JlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5iZWZvcmUodGhpcy5oYW5kbGVQcm9taXNlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugc3RhdHVzVHlwZXMucGVuZGluZzpcbiAgICAgICAgICAgIGlmIChwcm9wcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5wZW5kaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugc3RhdHVzVHlwZXMucmVzb2x2ZWQ6XG4gICAgICAgICAgICBpZiAocHJvcHMudGhlbikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMudGhlbihzdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBzdGF0dXNUeXBlcy5yZWplY3RlZDpcbiAgICAgICAgICAgIGlmIChwcm9wcy5jYXRjaCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuY2F0Y2goc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBc3luYztcbiAgfShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuICBBc3luYy5wcm9wVHlwZXMgPSB7XG4gICAgYmVmb3JlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICAgLy8gcmVuZGVycyBpdCdzIHJldHVybiB2YWx1ZSBiZWZvcmUgcHJvbWlzZSBpcyBoYW5kbGVkXG4gICAgdGhlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICAgIC8vIHJlbmRlcnMgaXQncyByZXR1cm4gdmFsdWUgd2hlbiBwcm9taXNlIGlzIHJlc29sdmVkXG4gICAgY2F0Y2g6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgICAvLyByZW5kZXJzIGl0J3MgcmV0dXJuIHZhbHVlIHdoZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICAgIHBlbmRpbmc6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgICAvLyByZW5kZXJzIGl0J3MgdmFsdWUgd2hlbiBwcm9taXNlIGlzIHBlbmRpbmdcbiAgICBwcm9taXNlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCAvLyBwcm9taXNlIGl0c2VsZlxuXG4gIH07XG5cbiAgLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cbiAgLyoqXG4gICAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAgICpcbiAgICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAgICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gICAqIGV4cGVjdGluZy5cbiAgICpcbiAgICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAgICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICAgKi9cblxuICB2YXIgTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblxuICB2YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaWYgKE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBlcnJvcjtcblxuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSkpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW52YXJpYW50XzEgPSBpbnZhcmlhbnQ7XG5cbiAgZnVuY3Rpb24gdXJsQnVpbGRlcihwcm9wZXJ0eSwgdmFsdWUsIHNlcGFyYXRvcikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGAke3Byb3BlcnR5fSR7c2VwYXJhdG9yfSR7dmFsdWV9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2NhdGlvbkJ1aWxkZXIobG9jYXRpb24pIHtcbiAgICBjb25zdCB1cmxQYXJ0cyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9jYXRpb24pKSB7XG4gICAgICBjb25zdCBhcnJQYXJ0cyA9IGxvY2F0aW9uLm1hcCh2YWwgPT4gbG9jYXRpb25CdWlsZGVyKHZhbCkpO1xuICAgICAgdXJsUGFydHMucHVzaCguLi5hcnJQYXJ0cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgdXJsUGFydHMucHVzaChsb2NhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcgJiYgbG9jYXRpb24ubGF0ICYmIGxvY2F0aW9uLmxuZykge1xuICAgICAgdXJsUGFydHMucHVzaChgJHtsb2NhdGlvbi5sYXR9LCR7bG9jYXRpb24ubG5nfWApO1xuICAgIH1cblxuICAgIHJldHVybiB1cmxQYXJ0cy5qb2luKCclN0MnKTsgLy8gfFxuICB9XG4gIGZ1bmN0aW9uIGlzU3RhdGVsZXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiAhY29tcG9uZW50LnJlbmRlciAmJiAhKGNvbXBvbmVudC5wcm90b3R5cGUgJiYgY29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY29tcG9uZW50ICYmIGNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCAmJiBjb21wb25lbnQucHJvdG90eXBlLnJlbmRlcik7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyU3RhdGVsZXNzQ29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICByZXR1cm4gY29tcG9uZW50KHByb3BzKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDbGFzc0NvbXBvbmVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpLnJlbmRlcigpO1xuICB9XG5cbiAgY29uc3QgbWFya2VyU3RyYXRlZ3kgPSAoe1xuICAgIHByb3BzLFxuICAgIHR5cGU6IHtcbiAgICAgIGRlZmF1bHRQcm9wc1xuICAgIH1cbiAgfSwgcGFyZW50UHJvcHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzaXplLFxuICAgICAgY29sb3IsXG4gICAgICBsYWJlbCxcbiAgICAgIGFuY2hvcixcbiAgICAgIGljb25VUkwsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHNjYWxlXG4gICAgfSA9IHByb3BzO1xuICAgIGludmFyaWFudF8xKGxvY2F0aW9uLCAnTWFya2VyIGV4cGVjdHMgYSB2YWxpZCBsb2NhdGlvbiBwcm9wJyk7XG4gICAgbGV0IHVybFBhcnRzID0gW107IC8vIFRvZG86IFJlbW92ZSB0aGUgcHJvcGVydHkgaWYgdGhlIGRlZmF1bHRQcm9wIGFuZCBQcm9wIHZhbHVlIGlzIHRoZSBzYW1lXG5cbiAgICB1cmxQYXJ0cy5wdXNoKHVybEJ1aWxkZXIoJ3NpemUnLCBzaXplLCAnOicpKTtcbiAgICB1cmxQYXJ0cy5wdXNoKHVybEJ1aWxkZXIoJ2NvbG9yJywgY29sb3IsICc6JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignbGFiZWwnLCBsYWJlbCwgJzonKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdhbmNob3InLCBhbmNob3IsICc6JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignc2NhbGUnLCBzY2FsZSwgJzonKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdpY29uJywgaWNvblVSTCwgJzonKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCcnLCBsb2NhdGlvbkJ1aWxkZXIobG9jYXRpb24pLCAnJykpO1xuICAgIGNvbnN0IHVybCA9IHVybFBhcnRzLmZpbHRlcih4ID0+IHgpLmpvaW4oJyU3QycpOyAvLyB8XG5cbiAgICByZXR1cm4gYG1hcmtlcnM9JHt1cmx9YDtcbiAgfTtcblxuICB2YXIgTWFya2VyU3RyYXRlZ3kgPSBtYXJrZXJTdHJhdGVneTtcblxuICBjb25zdCBwYXRoU3RyYXRlZ3kgPSAoe1xuICAgIHByb3BzLFxuICAgIHR5cGU6IHtcbiAgICAgIGRlZmF1bHRQcm9wc1xuICAgIH1cbiAgfSwgcGFyZW50UHJvcHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3ZWlnaHQsXG4gICAgICBjb2xvcixcbiAgICAgIGZpbGxjb2xvcixcbiAgICAgIGdlb2Rlc2ljLFxuICAgICAgcG9pbnRzXG4gICAgfSA9IHByb3BzO1xuICAgIGludmFyaWFudF8xKHBvaW50cywgJ1BhdGggZXhwZWN0cyBhIHZhbGlkIHBvaW50cyBwcm9wJyk7XG4gICAgY29uc3QgdXJsUGFydHMgPSBbXTsgLy8gVG9kbzogUmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgZGVmYXVsdFByb3AgYW5kIFByb3AgdmFsdWUgaXMgdGhlIHNhbWVcblxuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignY29sb3InLCBjb2xvciwgJzonKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCd3ZWlnaHQnLCB3ZWlnaHQsICc6JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignZmlsbGNvbG9yJywgZmlsbGNvbG9yLCAnOicpKTtcbiAgICB1cmxQYXJ0cy5wdXNoKHVybEJ1aWxkZXIoJ2dlb2Rlc2ljJywgZ2VvZGVzaWMsICc6JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignJywgbG9jYXRpb25CdWlsZGVyKHBvaW50cyksICcnKSk7XG4gICAgY29uc3QgdXJsID0gdXJsUGFydHMuZmlsdGVyKHggPT4geCkuam9pbignJTdDJyk7IC8vfFxuXG4gICAgcmV0dXJuIGBwYXRoPSR7dXJsfWA7XG4gIH07XG5cbiAgdmFyIFBhdGhTdHJhdGVneSA9IHBhdGhTdHJhdGVneTtcblxuICBjb25zdCBtYXJrZXJHcm91cFN0cmF0ZWd5ID0gKHtcbiAgICBwcm9wcyxcbiAgICB0eXBlOiB7XG4gICAgICBkZWZhdWx0UHJvcHNcbiAgICB9XG4gIH0sIHBhcmVudFByb3BzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgbGFiZWwsXG4gICAgICBhbmNob3IsXG4gICAgICBpY29uVVJMLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBzY2FsZVxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBsb2NhdGlvbiA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4gY2hpbGQucHJvcHMubG9jYXRpb24pO1xuICAgIHJldHVybiBNYXJrZXJTdHJhdGVneSh7XG4gICAgICBwcm9wczoge1xuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaWNvblVSTCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHNjYWxlXG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0UHJvcHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgTWFya2VyR3JvdXBTdHJhdGVneSA9IG1hcmtlckdyb3VwU3RyYXRlZ3k7XG5cbiAgY29uc3QgcGF0aEdyb3VwU3RyYXRlZ3kgPSAoe1xuICAgIHByb3BzLFxuICAgIHR5cGU6IHtcbiAgICAgIGRlZmF1bHRQcm9wc1xuICAgIH1cbiAgfSwgcGFyZW50UHJvcHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3ZWlnaHQsXG4gICAgICBjb2xvcixcbiAgICAgIGZpbGxjb2xvcixcbiAgICAgIGdlb2Rlc2ljLFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9pbnRzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBjaGlsZC5wcm9wcy5wb2ludHMpO1xuICAgIHJldHVybiBQYXRoU3RyYXRlZ3koe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgd2VpZ2h0LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZmlsbGNvbG9yLFxuICAgICAgICBnZW9kZXNpYyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0UHJvcHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgUGF0aEdyb3VwU3RyYXRlZ3kgPSBwYXRoR3JvdXBTdHJhdGVneTtcblxuICBmdW5jdGlvbiBuYXRpdmVTdHJhdGVneShkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luLFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB0cmF2ZWxNb2RlXG4gICAgfSA9IGRhdGE7XG4gICAgbGV0IG9yaWdpbkxvY2F0aW9uO1xuICAgIGxldCBkZXN0aW5hdGlvbkxvY2F0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmIG9yaWdpbi5sYXQgJiYgb3JpZ2luLmxuZykge1xuICAgICAgb3JpZ2luTG9jYXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG9yaWdpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbkxvY2F0aW9uID0gb3JpZ2luO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09ICdvYmplY3QnICYmIGRlc3RpbmF0aW9uLmxhdCAmJiBkZXN0aW5hdGlvbi5sbmcpIHtcbiAgICAgIGRlc3RpbmF0aW9uTG9jYXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGRlc3RpbmF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdGluYXRpb25Mb2NhdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IERpcmVjdGlvbnNTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTZXJ2aWNlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIERpcmVjdGlvbnNTZXJ2aWNlLnJvdXRlKHtcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5Mb2NhdGlvbixcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uTG9jYXRpb24sXG4gICAgICAgIHRyYXZlbE1vZGU6IHRyYXZlbE1vZGUudG9VcHBlckNhc2UoKVxuICAgICAgfSwgKHJlc3VsdCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTdGF0dXMuT0spIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdC5yb3V0ZXNbMF0ub3ZlcnZpZXdfcG9seWxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVqZWN0KHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3RyYXRlZ3koZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VVUkwsXG4gICAgICBrZXksXG4gICAgICBvcmlnaW4sXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgY2FjaGU6ICdkZWZhdWx0J1xuICAgIH07XG4gICAgbGV0IG9yaWdpbkxvY2F0aW9uO1xuICAgIGxldCBkZXN0aW5hdGlvbkxvY2F0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmIG9yaWdpbi5sYXQgJiYgb3JpZ2luLmxuZykge1xuICAgICAgb3JpZ2luTG9jYXRpb24gPSBgJHtvcmlnaW4ubGF0fSwke29yaWdpbi5sbmd9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luTG9jYXRpb24gPSBvcmlnaW47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ29iamVjdCcgJiYgZGVzdGluYXRpb24ubGF0ICYmIGRlc3RpbmF0aW9uLmxuZykge1xuICAgICAgZGVzdGluYXRpb25Mb2NhdGlvbiA9IGAke2Rlc3RpbmF0aW9uLmxhdH0sJHtkZXN0aW5hdGlvbi5sbmd9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdGluYXRpb25Mb2NhdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IFVSTCA9IGAke2Jhc2VVUkx9P29yaWdpbj0ke29yaWdpbkxvY2F0aW9ufSZkZXN0aW5hdGlvbj0ke2Rlc3RpbmF0aW9uTG9jYXRpb259JmtleT0ke2tleX1gO1xuICAgIHJldHVybiBmZXRjaChVUkwsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpLnRoZW4ocmVzID0+IHJlcy5yb3V0ZXNbMF0ub3ZlcnZpZXdfcG9seWxpbmUucG9pbnRzKTtcbiAgfVxuXG4gIGNvbnN0IF9leGNsdWRlZCQxID0gW1wiYmFzZVVSTFwiLCBcInJlcXVlc3RTdHJhdGVneVwiLCBcIm9yaWdpblwiLCBcImRlc3RpbmF0aW9uXCIsIFwiYXBpS2V5XCIsIFwid2F5cG9pbnRzXCIsIFwiYXZvaWRcIiwgXCJ0cmF2ZWxNb2RlXCIsIFwidHJhbnNpdE1vZGVcIiwgXCJ0cmFuc2l0Um91dGluZ1ByZWZlcmVuY2VcIiwgXCJ3ZWlnaHRcIiwgXCJjb2xvclwiLCBcImZpbGxjb2xvclwiLCBcImdlb2Rlc2ljXCJdO1xuICBjb25zdCBtZW1vaXplRGlyZWN0aW9uU3RyYXRlZ3kgPSAoZGlyZWN0aW9uU3RyYXRlZ3ksIGNhY2hlID0ge30pID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHtcbiAgICAgIHByb3BzXG4gICAgfSwgcGFyZW50UHJvcHMpIHtcbiAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHByb3BzKTtcblxuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gZGlyZWN0aW9uU3RyYXRlZ3kuYXBwbHkobnVsbCwgYXJndW1lbnRzKS50aGVuKHN0cmF0ID0+IHtcbiAgICAgICAgICAvLyBXaGVuIHRoaXMgZmluYWxseSByZXNvbHZlcywgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgY2FjaGUgdG9cbiAgICAgICAgICAvLyB0aGUgc3RyaW5nIHBhdGggcmVzdWx0LiBTdWJzZXF1ZW50IHJlbmRlcnMgd2lsbCByZXR1cm4gYSBzdHJpbmdcbiAgICAgICAgICAvLyBhbmQgdXNlIHRoZSBiYXNlIGNvbXBvbmVudCBpbnN0ZWFkIG9mIHRoZSBBc3luYyBjb21wb25lbnQgYW5kXG4gICAgICAgICAgLy8gbm90IGNhdXNlIHRoZSBmbGFzaFxuICAgICAgICAgIGNhY2hlW2tleV0gPSBzdHJhdDtcblxuICAgICAgICAgIGlmIChwYXJlbnRQcm9wcy5vbkNhY2hlVXBkYXRlKSB7XG4gICAgICAgICAgICBwYXJlbnRQcm9wcy5vbkNhY2hlVXBkYXRlKF9vYmplY3RTcHJlYWQyKHt9LCBjYWNoZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdHJhdDtcbiAgICAgICAgfSk7IC8vIFJldHVybiB0aGUgcGVuZGluZyBwcm9taXNlIGltbWVkaWV0bHkgYW5kIHRoZSBTdGF0aWNHb29nbGVNYXBcbiAgICAgICAgLy8gdXNhZ2Ugb2YgdGhlIEFzeW5jIGNvbXBvbmVudCB3aWxsIGV2ZW50dWFsbHkgaGFuZGxlIGl0IGJlY2F1c2VcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5lZCBhIFByb21pc2UuIFRoaXMgcGllY2Ugb2YgdGhlIGNvZGUgcHJldmVudHNcbiAgICAgICAgLy8gbXVsdGlwbGUgY2FsbHMgdG8gZ29vZ2xlIG9uIGVhY2ggcmVuZGVyLCBidXQgZG9lcyBub3Qgc29sdmUgdGhlXG4gICAgICAgIC8vIFwiZmxhc2hcIiBvZiB0aGUgQXN5bmMgY29tcG9uZW50LlxuXG4gICAgICAgIGNhY2hlW2tleV0gPSBwcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IGRpcmVjdGlvblN0cmF0ZWd5ID0gKHtcbiAgICBwcm9wcyxcbiAgICB0eXBlOiB7XG4gICAgICBkZWZhdWx0UHJvcHNcbiAgICB9XG4gIH0sIHBhcmVudFByb3BzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZVVSTCxcbiAgICAgIHJlcXVlc3RTdHJhdGVneSxcbiAgICAgIG9yaWdpbixcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgYXBpS2V5LFxuICAgICAgd2F5cG9pbnRzLFxuICAgICAgYXZvaWQsXG4gICAgICB0cmF2ZWxNb2RlLFxuICAgICAgdHJhbnNpdE1vZGUsXG4gICAgICB0cmFuc2l0Um91dGluZ1ByZWZlcmVuY2UsXG4gICAgICB3ZWlnaHQsXG4gICAgICBjb2xvcixcbiAgICAgIGZpbGxjb2xvcixcbiAgICAgIGdlb2Rlc2ljXG4gICAgfSA9IHByb3BzLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcblxuICAgIGludmFyaWFudF8xKG9yaWdpbiwgJ09yaWdpbiBwcm9wIGlzIHJlcXVpcmVkJyk7XG4gICAgaW52YXJpYW50XzEoZGVzdGluYXRpb24sICdEZXN0aW5hdGlvbiBwcm9wIGlzIHJlcXVpcmVkJyk7IC8vIFVzZSB0aGUgcGFyZW50J3MgQVBJIGtleSBpZiBvbmUgaXNuJ3Qgc2V0IGhlcmUuXG5cbiAgICBjb25zdCBrZXkgPSBhcGlLZXkgPyBhcGlLZXkgOiBwYXJlbnRQcm9wcyA/IHBhcmVudFByb3BzLmFwaUtleSA6ICcnO1xuXG4gICAgY29uc3QgZGF0YSA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGtleSxcbiAgICAgIGJhc2VVUkwsXG4gICAgICBvcmlnaW4sXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHdheXBvaW50cyxcbiAgICAgIGF2b2lkLFxuICAgICAgdHJhdmVsTW9kZSxcbiAgICAgIHRyYW5zaXRNb2RlLFxuICAgICAgdHJhbnNpdFJvdXRpbmdQcmVmZXJlbmNlXG4gICAgfSwgcmVzdCk7XG5cbiAgICBsZXQgcGF0aFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RTdHJhdGVneSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhQcm9taXNlID0gcmVxdWVzdFN0cmF0ZWd5KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKHJlcXVlc3RTdHJhdGVneSkge1xuICAgICAgICBjYXNlICduYXRpdmUnOlxuICAgICAgICAgIHBhdGhQcm9taXNlID0gbmF0aXZlU3RyYXRlZ3koZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZmV0Y2gnOlxuICAgICAgICAgIHBhdGhQcm9taXNlID0gZmV0Y2hTdHJhdGVneShkYXRhKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3BlY2lmeSBhIFJlcXVlc3Qgc3RyYXRlZ3kgdG8gZ2V0IGRpcmVjdGlvbnMgZnJvbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoUHJvbWlzZS50aGVuKHBhdGggPT4gUGF0aFN0cmF0ZWd5KHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHdlaWdodCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGZpbGxjb2xvcixcbiAgICAgICAgZ2VvZGVzaWMsXG4gICAgICAgIHBvaW50czogYGVuYzoke3BhdGh9YFxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgZGVmYXVsdFByb3BzXG4gICAgICB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHZhciBEaXJlY3Rpb25TdHJhdGVneSA9IGRpcmVjdGlvblN0cmF0ZWd5O1xuXG4gIGNvbnN0IE1hcFN0cmF0ZWd5ID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvb3RVUkwsXG4gICAgICBzaXplLFxuICAgICAgem9vbSxcbiAgICAgIHNjYWxlLFxuICAgICAgc3R5bGUsXG4gICAgICBtYXBJZCxcbiAgICAgIGNlbnRlcixcbiAgICAgIGZvcm1hdCxcbiAgICAgIGNsaWVudCxcbiAgICAgIHJlZ2lvbixcbiAgICAgIHZpc2libGUsXG4gICAgICBjaGFubmVsLFxuICAgICAgbWFwdHlwZSxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgYXBpS2V5XG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHVybFBhcnRzID0gW107XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdzaXplJywgc2l6ZSwgJz0nKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCd6b29tJywgem9vbSwgJz0nKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdzY2FsZScsIHNjYWxlLCAnPScpKTtcbiAgICB1cmxQYXJ0cy5wdXNoKHVybEJ1aWxkZXIoJ3N0eWxlJywgc3R5bGUsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignbWFwX2lkJywgbWFwSWQsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignY2VudGVyJywgY2VudGVyLCAnPScpKTsgLy8gVG9kbzogQWxsb3cgT2JqZWN0cy5cblxuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignZm9ybWF0JywgZm9ybWF0LCAnPScpKTtcbiAgICB1cmxQYXJ0cy5wdXNoKHVybEJ1aWxkZXIoJ2NsaWVudCcsIGNsaWVudCwgJz0nKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdyZWdpb24nLCByZWdpb24sICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcigndmlzaWJsZScsIHZpc2libGUsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignY2hhbm5lbCcsIGNoYW5uZWwsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignbWFwdHlwZScsIG1hcHR5cGUsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcignbGFuZ3VhZ2UnLCBsYW5ndWFnZSwgJz0nKSk7XG4gICAgdXJsUGFydHMucHVzaCh1cmxCdWlsZGVyKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsICc9JykpO1xuICAgIHVybFBhcnRzLnB1c2godXJsQnVpbGRlcigna2V5JywgYXBpS2V5LCAnPScpKTtcbiAgICBjb25zdCBwYXJ0cyA9IHVybFBhcnRzLmZpbHRlcih4ID0+IHgpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gYCR7cm9vdFVSTH0/JHtwYXJ0c31gO1xuICB9O1xuXG4gIHZhciBNYXBTdHJhdGVneSQxID0gTWFwU3RyYXRlZ3k7XG5cbiAgY29uc3QgcHJvcFR5cGVzJDIgPSB7XG4gICAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZihbJ3RpbnknLCAnbWlkJywgJ3NtYWxsJywgJ25vcm1hbCddKSxcbiAgICBjb2xvcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gICAgaWNvblVSTDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gICAgbGFiZWw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICAgIGFuY2hvcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gICAgbG9jYXRpb246IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYW55LmlzUmVxdWlyZWRcbiAgfTtcbiAgY29uc3QgZGVmYXVsdFByb3BzJDIgPSB7XG4gICAgc2l6ZTogJ25vcm1hbCdcbiAgfTtcbiAgY29uc3QgZ3JvdXBQcm9wVHlwZXMkMSA9IHtcbiAgICBzaXplOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsndGlueScsICdtaWQnLCAnc21hbGwnLCAnbm9ybWFsJ10pLFxuICAgIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBpY29uVVJMOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBsYWJlbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gICAgYW5jaG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xuICB9O1xuXG4gIGNvbnN0IE1hcmtlciA9ICgpID0+IG51bGw7XG5cbiAgTWFya2VyLnByb3BUeXBlcyA9IHByb3BUeXBlcyQyO1xuICBNYXJrZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDI7XG5cbiAgY29uc3QgTWFya2VyR3JvdXAgPSAoKSA9PiBudWxsO1xuXG4gIE1hcmtlckdyb3VwLnByb3BUeXBlcyA9IGdyb3VwUHJvcFR5cGVzJDE7XG4gIE1hcmtlckdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQyO1xuICBNYXJrZXIuR3JvdXAgPSBNYXJrZXJHcm91cDtcbiAgdmFyIE1hcmtlciQxID0gTWFya2VyO1xuXG4gIGNvbnN0IHByb3BUeXBlcyQxID0ge1xuICAgIHdlaWdodDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcl0pLFxuICAgIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBmaWxsY29sb3I6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICAgIGdlb2Rlc2ljOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gICAgcG9pbnRzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFueS5pc1JlcXVpcmVkXG4gIH07XG4gIGNvbnN0IGdyb3VwUHJvcFR5cGVzID0ge1xuICAgIHdlaWdodDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcl0pLFxuICAgIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBmaWxsY29sb3I6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICAgIGdlb2Rlc2ljOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbiAgfTtcbiAgY29uc3QgZGVmYXVsdFByb3BzJDEgPSB7XG4gICAgd2VpZ2h0OiA1LFxuICAgIGdlb2Rlc2ljOiBmYWxzZVxuICB9O1xuXG4gIGNvbnN0IFBhdGggPSAoKSA9PiBudWxsO1xuXG4gIFBhdGgucHJvcFR5cGVzID0gcHJvcFR5cGVzJDE7XG4gIFBhdGguZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE7XG5cbiAgY29uc3QgUGF0aEdyb3VwID0gKCkgPT4gbnVsbDtcblxuICBQYXRoR3JvdXAucHJvcHNUeXBlcyA9IGdyb3VwUHJvcFR5cGVzO1xuICBQYXRoR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE7XG4gIFBhdGguR3JvdXAgPSBQYXRoR3JvdXA7XG4gIHZhciBQYXRoJDEgPSBQYXRoO1xuXG4gIGNvbnN0IHByb3BUeXBlcyA9IHtcbiAgICBiYXNlVVJMOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBvcmlnaW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgZGVzdGluYXRpb246IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYXBpS2V5OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICB3YXlwb2ludHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYW55LFxuICAgIGF2b2lkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICB0cmF2ZWxNb2RlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnZHJpdmluZycsICd3YWxraW5nJywgJ2JpY3ljbGluZycsICd0cmFuc2l0J10pLFxuICAgIHRyYW5zaXRNb2RlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnYnVzJywgJ3N1YndheScsICd0cmFpbicsICd0cmFtJywgJ3JhaWwnXSksXG4gICAgdHJhbnNpdFJvdXRpbmdQcmVmZXJlbmNlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnbGVzc193YWxraW5nJywgJ2Zld2VyX3RyYW5zZmVycyddKSxcbiAgICByZXF1ZXN0U3RyYXRlZ3k6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoWydmZXRjaCcsICduYXRpdmUnXSldKS5pc1JlcXVpcmVkLFxuICAgIHdlaWdodDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcl0pLFxuICAgIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICBmaWxsY29sb3I6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICAgIGdlb2Rlc2ljOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbiAgfTtcbiAgY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAgIGJhc2VVUkw6ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvZGlyZWN0aW9ucy9qc29uJyxcbiAgICB0cmF2ZWxNb2RlOiAnZHJpdmluZycsXG4gICAgcmVxdWVzdFN0cmF0ZWd5OiAnbmF0aXZlJyxcbiAgICB3ZWlnaHQ6IDUsXG4gICAgZ2VvZGVzaWM6IGZhbHNlXG4gIH07XG5cbiAgY29uc3QgRGlyZWN0aW9uID0gKCkgPT4gbnVsbDtcblxuICBEaXJlY3Rpb24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuICBEaXJlY3Rpb24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuICB2YXIgRGlyZWN0aW9uJDEgPSBEaXJlY3Rpb247XG5cbiAgY29uc3QgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIiwgXCJvbkdlbmVyYXRlXCIsIFwiYXNcIl0sXG4gICAgICAgIF9leGNsdWRlZDIgPSBbXCJyb290VVJMXCIsIFwic2l6ZVwiLCBcInpvb21cIiwgXCJzY2FsZVwiLCBcInN0eWxlXCIsIFwibWFwSWRcIiwgXCJjZW50ZXJcIiwgXCJmb3JtYXRcIiwgXCJjbGllbnRcIiwgXCJyZWdpb25cIiwgXCJ2aXNpYmxlXCIsIFwiY2hhbm5lbFwiLCBcIm1hcHR5cGVcIiwgXCJsYW5ndWFnZVwiLCBcInNpZ25hdHVyZVwiLCBcImFwaUtleVwiLCBcImNhY2hlXCIsIFwib25DYWNoZVVwZGF0ZVwiXTtcblxuICBjbGFzcyBTdGF0aWNHb29nbGVNYXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJNZW1vaXplZERpcmVjdGlvblN0cmF0ZWd5XCIsIG1lbW9pemVEaXJlY3Rpb25TdHJhdGVneShEaXJlY3Rpb25TdHJhdGVneSwgX29iamVjdFNwcmVhZDIoe30sIHRoaXMucHJvcHMuY2FjaGUpKSk7XG4gICAgfVxuXG4gICAgYnVpbGRQYXJ0cyhjaGlsZHJlbiwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIE1hcmtlciQxOlxuICAgICAgICAgICAgcmV0dXJuIE1hcmtlclN0cmF0ZWd5KGNoaWxkLCBwcm9wcyk7XG5cbiAgICAgICAgICBjYXNlIE1hcmtlciQxLkdyb3VwOlxuICAgICAgICAgICAgcmV0dXJuIE1hcmtlckdyb3VwU3RyYXRlZ3koY2hpbGQsIHByb3BzKTtcblxuICAgICAgICAgIGNhc2UgUGF0aCQxOlxuICAgICAgICAgICAgcmV0dXJuIFBhdGhTdHJhdGVneShjaGlsZCwgcHJvcHMpO1xuXG4gICAgICAgICAgY2FzZSBQYXRoJDEuR3JvdXA6XG4gICAgICAgICAgICByZXR1cm4gUGF0aEdyb3VwU3RyYXRlZ3koY2hpbGQsIHByb3BzKTtcblxuICAgICAgICAgIGNhc2UgRGlyZWN0aW9uJDE6XG4gICAgICAgICAgICBpZiAocHJvcHMuY2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTWVtb2l6ZWREaXJlY3Rpb25TdHJhdGVneShjaGlsZCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9uU3RyYXRlZ3koY2hpbGQsIHByb3BzKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gY2hpbGQudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzU3RhdGVsZXNzQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkUGFydHMocmVuZGVyU3RhdGVsZXNzQ29tcG9uZW50KGNvbXBvbmVudFR5cGUsIF9vYmplY3RTcHJlYWQyKHt9LCBjaGlsZC5wcm9wcykpLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkUGFydHMocmVuZGVyQ2xhc3NDb21wb25lbnQoY29tcG9uZW50VHlwZSwgX29iamVjdFNwcmVhZDIoe30sIGNoaWxkLnByb3BzKSksIHByb3BzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9uR2VuZXJhdGUsXG4gICAgICAgIGFzOiBDb21wb25lbnRcbiAgICAgIH0gPSBfdGhpcyRwcm9wcyxcbiAgICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvb3RVUkwsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHpvb20sXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgbWFwSWQsXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlZ2lvbixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgbWFwdHlwZSxcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYXBpS2V5LFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgb25DYWNoZVVwZGF0ZVxuICAgICAgfSA9IHByb3BzLFxuICAgICAgICAgICAgY29tcG9uZW50UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZDIpO1xuXG4gICAgICBpbnZhcmlhbnRfMShzaXplLCAnc2l6ZSBwcm9wZXJ0eSBpcyBub3Qgc2V0Jyk7XG4gICAgICBpbnZhcmlhbnRfMShjaGlsZHJlbiwgJ0NvbXBvbmVudCBtdXN0IGhhdmUgYE1hcmtlcmAsIGBQYXRoYCBvciBgRGlyZWN0aW9uYCBjaGlsZCcpO1xuICAgICAgY29uc3QgY2hpbGRyZW5VcmxQYXJ0cyA9IHRoaXMuYnVpbGRQYXJ0cyhjaGlsZHJlbiwgcHJvcHMpIHx8IFtdO1xuICAgICAgY29uc3QgbWFpblVybFBhcnRzID0gTWFwU3RyYXRlZ3kkMShwcm9wcyk7XG4gICAgICAvKipcbiAgICAgICAqIEFsbCB0aGUgcGFydHMgc2hvdWxkIHJldHVybiBhIHN0cmluZyBpZiBhIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJldHVybiBhIHByb21pc2UgaXNuJ3QgdXNlZFxuICAgICAgICogVGhlIERpcmVjdGlvbnMncyBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UgYW5kIHdvdWxkIGluc3RlYWQgdXNlIHRoZSBBc3luYyBjb21wb25lbnQgdG8gcmVuZGVyXG4gICAgICAgKiBUaGlzIGFsbG93cyB1cyByZW5kZXIgc3luYyBvdGhlcndpc2UgYW5kIHBhcnRpYWxseSBzdXBwb3J0IHNlcnZlciBzaWRlIHJlbmRlcmluZy5cbiAgICAgICAqL1xuXG4gICAgICBpZiAoIWNoaWxkcmVuVXJsUGFydHMuc29tZShwYXJ0ID0+IHR5cGVvZiBwYXJ0ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgY29uc3QgY2hpbGRVUkwgPSBjaGlsZHJlblVybFBhcnRzLmZpbHRlcihwYXJ0ID0+IHBhcnQpLmpvaW4oJyYnKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7bWFpblVybFBhcnRzfSYke2NoaWxkVVJMfWA7XG5cbiAgICAgICAgaWYgKG9uR2VuZXJhdGUpIHtcbiAgICAgICAgICBvbkdlbmVyYXRlKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGNvbXBvbmVudFByb3BzLCB7XG4gICAgICAgICAgc3JjOiB1cmxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmxQYXJ0cyA9IFByb21pc2UuYWxsKGNoaWxkcmVuVXJsUGFydHMpLnRoZW4ocGFydHMgPT4gYCR7bWFpblVybFBhcnRzfSYke3BhcnRzLmZpbHRlcihwYXJ0ID0+IHBhcnQpLmpvaW4oJyYnKX1gKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQXN5bmMsIHtcbiAgICAgICAgcHJvbWlzZTogdXJsUGFydHMsXG4gICAgICAgIHRoZW46IFVSTCA9PiB7XG4gICAgICAgICAgaWYgKG9uR2VuZXJhdGUpIHtcbiAgICAgICAgICAgIG9uR2VuZXJhdGUoVVJMKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGNvbXBvbmVudFByb3BzLCB7XG4gICAgICAgICAgICBzcmM6IFVSTFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2F0Y2g6IGVyciA9PiAoY29uc29sZS5lcnJvcihlcnIpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiSW1hZ2UgZ2VuZXJhdGlvbiBmYWlsZWQuXCIpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBfZGVmaW5lUHJvcGVydHkoU3RhdGljR29vZ2xlTWFwLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgYXM6ICdpbWcnLFxuICAgIHNjYWxlOiAxLFxuICAgIGZvcm1hdDogJ3BuZycsXG4gICAgcm9vdFVSTDogJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXAnLFxuICAgIGFwaUtleTogJycsXG4gICAgbWFwdHlwZTogJ3JvYWRtYXAnLFxuICAgIGNhY2hlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBTdGF0aWNHb29nbGVNYXAkMSA9IFN0YXRpY0dvb2dsZU1hcDtcblxuICBleHBvcnRzLkRpcmVjdGlvbiA9IERpcmVjdGlvbiQxO1xuICBleHBvcnRzLk1hcmtlciA9IE1hcmtlciQxO1xuICBleHBvcnRzLlBhdGggPSBQYXRoJDE7XG4gIGV4cG9ydHMuU3RhdGljR29vZ2xlTWFwID0gU3RhdGljR29vZ2xlTWFwJDE7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-static-google-map/dist/react-static-google-map.umd.js\n"));

/***/ })

});